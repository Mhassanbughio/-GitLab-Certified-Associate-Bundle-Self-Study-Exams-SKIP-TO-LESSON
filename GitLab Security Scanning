GitLab provides several built in security scanners, these can be easily added to your .
gitlab-ci.yml files by using the includes -template feature. Read more about the various options below!


Security scanner integration
Integrating a security scanner into GitLab consists of providing end users with a CI job definition they can add to their CI configuration files to scan their GitLab projects. 
This CI job should then output its results in a GitLab-specified format.
These results are then automatically presented in various places in GitLab, such as the Pipeline view, Merge Request widget, and Security Dashboard.

The scanning job is usually based on a Docker image that contains the scanner and all its dependencies in a self-contained environment.

This page documents requirements and guidelines for writing CI jobs that implement a security scanner, as well as requirements and guidelines for the Docker image.


Job definition
This section describes several important fields to add to the security scanner’s job definition file. 
Full documentation on these and other available fields can be viewed in the CI documentation.

Name
For consistency, scanning jobs should be named after the scanner, in lower case. The job name is suffixed after the type of scanning: _dependency_scanning, _container_scanning, _dast, 
and _sast. For instance, the dependency scanning job based on the “MySec” scanner would be named mysec_dependency_scanning.

Image

The image keyword is used to specify the Docker image containing the security scanner.

Script
The script keyword is used to specify the commands to run the scanner. Because the script entry can’t be left empty, it must be set to the command that performs the scan.
It is not possible to rely on the predefined ENTRYPOINT and CMD of the Docker image to perform the scan automatically, without passing any command.

The before_script should not be used in the job definition because users may rely on this to prepare their projects before performing the scan. 
For instance, it is common practice to use before_script to install system libraries a particular project needs before performing SAST or Dependency Scanning.

Similarly, after_script should not be used in the job definition, because it may be overridden by users.

The artifacts:reports keyword of the job definition must be consistent with the file path where the Security report is written.
For instance, if a Dependency Scanning analyzer writes its report to the CI project directory, and if this report filename is depscan.json, then artifacts:reports:dependency_scanning must be set to depscan.json.

Exit code
Following the POSIX exit code standard, the scanner exits with 0 for success and any number from 1 to 255 for anything else.
Success also includes the case when vulnerabilities are found.

When executing a scanning job using the Docker-in-Docker privileged mode, we reserve the following standard exit codes.

Stage

For consistency, scanning jobs should belong to the test stage when possible. The stage keyword can be omitted because test is the default value.

Fail-safe
To be aligned with the GitLab Security paradigm, scanning jobs should not block the pipeline when they fail, so the allow_failure parameter should be set to true.

Artifacts

Scanning jobs must declare a report that corresponds to the type of scanning they perform, using the artifacts:reports keyword.
Valid reports are: dependency_scanning, container_scanning, dast, api_fuzzing, coverage_fuzzing, and sast.

For example, here is the definition of a SAST job that generates a file named gl-sast-report.json, and uploads it as a SAST report:

//////////////////////////////code
mysec_sast:
  image: registry.gitlab.com/secure/mysec
  artifacts:
    reports:
      sast: gl-sast-report.json
      
      
Note that gl-sast-report.json is an example file path but any other filename can be used. See the Output file section for more details. 
It’s processed as a SAST report because it’s declared under the reports:sast key in the job definition, not because of the filename.

Policies
Certain GitLab workflows, such as AutoDevOps, define CI/CD variables to indicate that given scans should be disabled. 
You can check for this by looking for variables such as DEPENDENCY_SCANNING_DISABLED, CONTAINER_SCANNING_DISABLED, SAST_DISABLED, and DAST_DISABLED.
If appropriate based on the scanner type, you should then disable running the custom scanner.
      
      
GitLab also defines a CI_PROJECT_REPOSITORY_LANGUAGES variable, which provides the list of languages in the repository. 
Depending on this value, your scanner may or may not do something different. Language detection currently relies on the linguist Ruby gem. See the predefined CI/CD variables.

Policy checking example

Policy checking example
This example shows how to skip a custom Dependency Scanning job, mysec_dependency_scanning, unless the project repository contains Java source code and the dependency_scanning feature is enabled:

####################################################    code 
mysec_dependency_scanning:
  rules:
    - if: $DEPENDENCY_SCANNING_DISABLED
      when: never
    - if: $GITLAB_FEATURES =~ /\bdependency_scanning\b/
      exists:
        - '**/*.java'
        
        Any additional job policy should only be configured by users based on their needs. For instance, 
        predefined policies should not trigger the scanning job for a particular branch or when a particular set of files changes.

Docker image
The Docker image is a self-contained environment that combines the scanner with all the libraries and tools it depends on. 
Packaging your scanner into a Docker image makes its dependencies and configuration always present, regardless of the individual machine the scanner runs on.

Image size
        Depending on the CI infrastructure, the CI may have to fetch the Docker image every time the job runs. 
        For the scanning job to run fast and avoid wasting bandwidth, Docker images should be as small as possible. 
        You should aim for 50MB or smaller. If that isn’t possible, try to keep it below 1.46 GB, which is the size of a CD-ROM.

If the scanner requires a fully functional Linux environment, it is recommended to use a Debian “slim” distribution or Alpine Linux. 
If possible, it is recommended to build the image from scratch, using the FROM scratch instruction, and to compile the scanner with all the libraries it needs. Multi-stage builds might also help with keeping the image small.

To keep an image size small, consider using dive to analyze layers in a Docker image to identify where additional bloat might be originating from.

In some cases, it might be difficult to remove files from an image. When this occurs, consider using Zstandard to compress files or large directories. Zstandard 
offers many different compression levels that can decrease the size of your image with very little impact to decompression speed. It may be helpful to 
automatically decompress any compressed directories as soon as an image launches. You can accomplish this by adding a step to the Docker image’s /etc/bashrc or to a specific user’s $HOME/.bashrc. 
Remember to change the entry point to launch a bash login shell if you chose the latter option.

Here are some examples to get you started:

https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/install.sh#L168-170
https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/.bashrc#L49

Image tag
As documented in the Docker Official Images project, it is strongly encouraged that version number tags be given aliases which allows 
the user to easily refer to the “most recent” release of a particular series. See also Docker Tagging: Best practices for tagging and versioning Docker images.

Command line
A scanner is a command line tool that takes environment variables as inputs, and generates a file that is uploaded as a report (based on the job definition). 
It also generates text output on the standard output and standard error streams, and exits with a status code.

Variables
All CI/CD variables are passed to the scanner as environment variables. The scanned project is described by the predefined CI/CD variables.

SAST and Dependency Scanning
SAST and Dependency Scanning scanners must scan the files in the project directory, given by the CI_PROJECT_DIR CI/CD variable.

Container Scanning
In order to be consistent with the official Container Scanning for GitLab, scanners must scan the Docker image whose name and tag are given by 
CI_APPLICATION_REPOSITORY and CI_APPLICATION_TAG, respectively. If the DOCKER_IMAGE CI/CD variable is provided,
then the CI_APPLICATION_REPOSITORY and CI_APPLICATION_TAG variables are ignored, and the image specified in the DOCKER_IMAGE variable is scanned instead.

If not provided, CI_APPLICATION_REPOSITORY should default to $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG, which is a combination of predefined CI/CD variables. 
CI_APPLICATION_TAG should default to CI_COMMIT_SHA.

The scanner should sign in the Docker registry using the variables DOCKER_USER and DOCKER_PASSWORD. If these are not defined, then the scanner should use CI_REGISTRY_USER and CI_REGISTRY_PASSWORD as default values.

Configuration files
While scanners may use CI_PROJECT_DIR to load specific configuration files, it is recommended to expose configuration as CI/CD variables, not files.

Output file
Like any artifact uploaded to GitLab CI/CD, the Secure report generated by the scanner must be written in the project directory, given by the CI_PROJECT_DIR CI/CD variable.

It is recommended to name the output file after the type of scanning, and to use gl- as a prefix. Since all Secure reports are JSON files, it is recommended to use .
json as a file extension. For instance, a suggested filename for a Dependency Scanning report is gl-dependency-scanning.json.

Orchestrator Exit Code	Description
3	No match, no compatible analyzer
4	Project directory empty
5	No compatible Docker image
Logging


The scanner should log error messages and warnings so that users can easily investigate misconfiguration and integration issues by looking at the log of the CI scanning job.

Scanners may use ANSI escape codes to colorize the messages they write to the Unix standard output and standard error streams.
We recommend using red to report errors, yellow for warnings, and green for notices. Also, we recommend prefixing error messages with [ERRO], warnings with [WARN], and notices with [INFO].

Logging level
The scanner should filter out a log message if its log level is lower than the one set in the SECURE_LOG_LEVEL CI/CD variable. For instance, 
info and warn messages should be skipped when SECURE_LOG_LEVEL is set to error. Accepted values are as follows, listed from highest to lowest:
fatal
error
warn
info
debug
It is recommended to use the debug level for verbose logging that could be useful when debugging. The default value for SECURE_LOG_LEVEL should be set to info.

When executing command lines, scanners should use the debug level to log the command line and its output. For instance, the bundler-audit scanner uses the debug level to log the command line bundle audit check --quiet, and what bundle audit writes to the standard output. If the command line fails, then it should be logged with the error log level; this makes it possible to debug the problem without having to change the log level to debug and rerun the scanning job.

common logutil package
