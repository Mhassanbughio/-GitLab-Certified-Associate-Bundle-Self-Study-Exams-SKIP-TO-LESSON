GitLab provides several built in security scanners, these can be easily added to your .
gitlab-ci.yml files by using the includes -template feature. Read more about the various options below!


Security scanner integration
Integrating a security scanner into GitLab consists of providing end users with a CI job definition they can add to their CI configuration files to scan their GitLab projects. 
This CI job should then output its results in a GitLab-specified format.
These results are then automatically presented in various places in GitLab, such as the Pipeline view, Merge Request widget, and Security Dashboard.

The scanning job is usually based on a Docker image that contains the scanner and all its dependencies in a self-contained environment.

This page documents requirements and guidelines for writing CI jobs that implement a security scanner, as well as requirements and guidelines for the Docker image.


Job definition
This section describes several important fields to add to the security scanner’s job definition file. 
Full documentation on these and other available fields can be viewed in the CI documentation.

Name
For consistency, scanning jobs should be named after the scanner, in lower case. The job name is suffixed after the type of scanning: _dependency_scanning, _container_scanning, _dast, 
and _sast. For instance, the dependency scanning job based on the “MySec” scanner would be named mysec_dependency_scanning.

Image

The image keyword is used to specify the Docker image containing the security scanner.

Script
The script keyword is used to specify the commands to run the scanner. Because the script entry can’t be left empty, it must be set to the command that performs the scan.
It is not possible to rely on the predefined ENTRYPOINT and CMD of the Docker image to perform the scan automatically, without passing any command.

The before_script should not be used in the job definition because users may rely on this to prepare their projects before performing the scan. 
For instance, it is common practice to use before_script to install system libraries a particular project needs before performing SAST or Dependency Scanning.

Similarly, after_script should not be used in the job definition, because it may be overridden by users.

Stage

For consistency, scanning jobs should belong to the test stage when possible. The stage keyword can be omitted because test is the default value.

Fail-safe
To be aligned with the GitLab Security paradigm, scanning jobs should not block the pipeline when they fail, so the allow_failure parameter should be set to true.

Artifacts

Scanning jobs must declare a report that corresponds to the type of scanning they perform, using the artifacts:reports keyword.
Valid reports are: dependency_scanning, container_scanning, dast, api_fuzzing, coverage_fuzzing, and sast.

For example, here is the definition of a SAST job that generates a file named gl-sast-report.json, and uploads it as a SAST report:

//////////////////////////////code
mysec_sast:
  image: registry.gitlab.com/secure/mysec
  artifacts:
    reports:
      sast: gl-sast-report.json
      
      
Note that gl-sast-report.json is an example file path but any other filename can be used. See the Output file section for more details. 
It’s processed as a SAST report because it’s declared under the reports:sast key in the job definition, not because of the filename.

Policies
Certain GitLab workflows, such as AutoDevOps, define CI/CD variables to indicate that given scans should be disabled. 
You can check for this by looking for variables such as DEPENDENCY_SCANNING_DISABLED, CONTAINER_SCANNING_DISABLED, SAST_DISABLED, and DAST_DISABLED.
If appropriate based on the scanner type, you should then disable running the custom scanner.
      
      
GitLab also defines a CI_PROJECT_REPOSITORY_LANGUAGES variable, which provides the list of languages in the repository. 
Depending on this value, your scanner may or may not do something different. Language detection currently relies on the linguist Ruby gem. See the predefined CI/CD variables.

Policy checking example

Policy checking example
This example shows how to skip a custom Dependency Scanning job, mysec_dependency_scanning, unless the project repository contains Java source code and the dependency_scanning feature is enabled:

####################################################    code 
mysec_dependency_scanning:
  rules:
    - if: $DEPENDENCY_SCANNING_DISABLED
      when: never
    - if: $GITLAB_FEATURES =~ /\bdependency_scanning\b/
      exists:
        - '**/*.java'
        
        Any additional job policy should only be configured by users based on their needs. For instance, 
        predefined policies should not trigger the scanning job for a particular branch or when a particular set of files changes.

Docker image
The Docker image is a self-contained environment that combines the scanner with all the libraries and tools it depends on. 
Packaging your scanner into a Docker image makes its dependencies and configuration always present, regardless of the individual machine the scanner runs on.

Image size
        Depending on the CI infrastructure, the CI may have to fetch the Docker image every time the job runs. 
        For the scanning job to run fast and avoid wasting bandwidth, Docker images should be as small as possible. 
        You should aim for 50MB or smaller. If that isn’t possible, try to keep it below 1.46 GB, which is the size of a CD-ROM.

If the scanner requires a fully functional Linux environment, it is recommended to use a Debian “slim” distribution or Alpine Linux. 
If possible, it is recommended to build the image from scratch, using the FROM scratch instruction, and to compile the scanner with all the libraries it needs. Multi-stage builds might also help with keeping the image small.

To keep an image size small, consider using dive to analyze layers in a Docker image to identify where additional bloat might be originating from.

In some cases, it might be difficult to remove files from an image. When this occurs, consider using Zstandard to compress files or large directories. Zstandard offers many different compression levels that can decrease the size of your image with very little impact to decompression speed. It may be helpful to automatically decompress any compressed directories as soon as an image launches. You can accomplish this by adding a step to the Docker image’s /etc/bashrc or to a specific user’s $HOME/.bashrc. Remember to change the entry point to launch a bash login shell if you chose the latter option.

Here are some examples to get you started:

https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/install.sh#L168-170
https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/.bashrc#L49

Image tag
As documented in the Docker Official Images project, it is strongly encouraged that version number tags be given aliases which allows the user to easily refer to the “most recent” release of a particular series. See also Docker Tagging: Best practices for tagging and versioning Docker images.

Command line
A scanner is a command line tool that takes environment variables as inputs, and generates a file that is uploaded as a report (based on the job definition). It also generates text output on the standard output and standard error streams, and exits with a status code.

Variables
All CI/CD variables are passed to the scanner as environment variables. The scanned project is described by the predefined CI/CD variables.

SAST and Dependency Scanning



