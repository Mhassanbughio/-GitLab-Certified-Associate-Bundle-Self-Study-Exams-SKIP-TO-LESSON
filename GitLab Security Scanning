GitLab provides several built in security scanners, these can be easily added to your .
gitlab-ci.yml files by using the includes -template feature. Read more about the various options below!


Security scanner integration
Integrating a security scanner into GitLab consists of providing end users with a CI job definition they can add to their CI configuration files to scan their GitLab projects. 
This CI job should then output its results in a GitLab-specified format.
These results are then automatically presented in various places in GitLab, such as the Pipeline view, Merge Request widget, and Security Dashboard.

The scanning job is usually based on a Docker image that contains the scanner and all its dependencies in a self-contained environment.

This page documents requirements and guidelines for writing CI jobs that implement a security scanner, as well as requirements and guidelines for the Docker image.


Job definition
This section describes several important fields to add to the security scanner’s job definition file. 
Full documentation on these and other available fields can be viewed in the CI documentation.

Name
For consistency, scanning jobs should be named after the scanner, in lower case. The job name is suffixed after the type of scanning: _dependency_scanning, _container_scanning, _dast, 
and _sast. For instance, the dependency scanning job based on the “MySec” scanner would be named mysec_dependency_scanning.

Image

The image keyword is used to specify the Docker image containing the security scanner.

Script
The script keyword is used to specify the commands to run the scanner. Because the script entry can’t be left empty, it must be set to the command that performs the scan.
It is not possible to rely on the predefined ENTRYPOINT and CMD of the Docker image to perform the scan automatically, without passing any command.

The before_script should not be used in the job definition because users may rely on this to prepare their projects before performing the scan. 
For instance, it is common practice to use before_script to install system libraries a particular project needs before performing SAST or Dependency Scanning.

Similarly, after_script should not be used in the job definition, because it may be overridden by users.

The artifacts:reports keyword of the job definition must be consistent with the file path where the Security report is written.
For instance, if a Dependency Scanning analyzer writes its report to the CI project directory, and if this report filename is depscan.json, then artifacts:reports:dependency_scanning must be set to depscan.json.

Exit code
Following the POSIX exit code standard, the scanner exits with 0 for success and any number from 1 to 255 for anything else.
Success also includes the case when vulnerabilities are found.

When executing a scanning job using the Docker-in-Docker privileged mode, we reserve the following standard exit codes.

Stage

For consistency, scanning jobs should belong to the test stage when possible. The stage keyword can be omitted because test is the default value.

Fail-safe
To be aligned with the GitLab Security paradigm, scanning jobs should not block the pipeline when they fail, so the allow_failure parameter should be set to true.

Artifacts

Scanning jobs must declare a report that corresponds to the type of scanning they perform, using the artifacts:reports keyword.
Valid reports are: dependency_scanning, container_scanning, dast, api_fuzzing, coverage_fuzzing, and sast.

For example, here is the definition of a SAST job that generates a file named gl-sast-report.json, and uploads it as a SAST report:

//////////////////////////////code
mysec_sast:
  image: registry.gitlab.com/secure/mysec
  artifacts:
    reports:
      sast: gl-sast-report.json
      
      
Note that gl-sast-report.json is an example file path but any other filename can be used. See the Output file section for more details. 
It’s processed as a SAST report because it’s declared under the reports:sast key in the job definition, not because of the filename.

Policies
Certain GitLab workflows, such as AutoDevOps, define CI/CD variables to indicate that given scans should be disabled. 
You can check for this by looking for variables such as DEPENDENCY_SCANNING_DISABLED, CONTAINER_SCANNING_DISABLED, SAST_DISABLED, and DAST_DISABLED.
If appropriate based on the scanner type, you should then disable running the custom scanner.
      
      
GitLab also defines a CI_PROJECT_REPOSITORY_LANGUAGES variable, which provides the list of languages in the repository. 
Depending on this value, your scanner may or may not do something different. Language detection currently relies on the linguist Ruby gem. See the predefined CI/CD variables.

Policy checking example

Policy checking example
This example shows how to skip a custom Dependency Scanning job, mysec_dependency_scanning, unless the project repository contains Java source code and the dependency_scanning feature is enabled:

####################################################    code 
mysec_dependency_scanning:
  rules:
    - if: $DEPENDENCY_SCANNING_DISABLED
      when: never
    - if: $GITLAB_FEATURES =~ /\bdependency_scanning\b/
      exists:
        - '**/*.java'
        
        Any additional job policy should only be configured by users based on their needs. For instance, 
        predefined policies should not trigger the scanning job for a particular branch or when a particular set of files changes.

Docker image
The Docker image is a self-contained environment that combines the scanner with all the libraries and tools it depends on. 
Packaging your scanner into a Docker image makes its dependencies and configuration always present, regardless of the individual machine the scanner runs on.

Image size
        Depending on the CI infrastructure, the CI may have to fetch the Docker image every time the job runs. 
        For the scanning job to run fast and avoid wasting bandwidth, Docker images should be as small as possible. 
        You should aim for 50MB or smaller. If that isn’t possible, try to keep it below 1.46 GB, which is the size of a CD-ROM.

If the scanner requires a fully functional Linux environment, it is recommended to use a Debian “slim” distribution or Alpine Linux. 
If possible, it is recommended to build the image from scratch, using the FROM scratch instruction, and to compile the scanner with all the libraries it needs. Multi-stage builds might also help with keeping the image small.

To keep an image size small, consider using dive to analyze layers in a Docker image to identify where additional bloat might be originating from.

In some cases, it might be difficult to remove files from an image. When this occurs, consider using Zstandard to compress files or large directories. Zstandard 
offers many different compression levels that can decrease the size of your image with very little impact to decompression speed. It may be helpful to 
automatically decompress any compressed directories as soon as an image launches. You can accomplish this by adding a step to the Docker image’s /etc/bashrc or to a specific user’s $HOME/.bashrc. 
Remember to change the entry point to launch a bash login shell if you chose the latter option.

Here are some examples to get you started:

https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/install.sh#L168-170
https://gitlab.com/gitlab-org/security-products/license-management/-/blob/0b976fcffe0a9b8e80587adb076bcdf279c9331c/config/.bashrc#L49

Image tag
As documented in the Docker Official Images project, it is strongly encouraged that version number tags be given aliases which allows 
the user to easily refer to the “most recent” release of a particular series. See also Docker Tagging: Best practices for tagging and versioning Docker images.

Command line
A scanner is a command line tool that takes environment variables as inputs, and generates a file that is uploaded as a report (based on the job definition). 
It also generates text output on the standard output and standard error streams, and exits with a status code.

Variables
All CI/CD variables are passed to the scanner as environment variables. The scanned project is described by the predefined CI/CD variables.

SAST and Dependency Scanning
SAST and Dependency Scanning scanners must scan the files in the project directory, given by the CI_PROJECT_DIR CI/CD variable.

Container Scanning
In order to be consistent with the official Container Scanning for GitLab, scanners must scan the Docker image whose name and tag are given by 
CI_APPLICATION_REPOSITORY and CI_APPLICATION_TAG, respectively. If the DOCKER_IMAGE CI/CD variable is provided,
then the CI_APPLICATION_REPOSITORY and CI_APPLICATION_TAG variables are ignored, and the image specified in the DOCKER_IMAGE variable is scanned instead.

If not provided, CI_APPLICATION_REPOSITORY should default to $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG, which is a combination of predefined CI/CD variables. 
CI_APPLICATION_TAG should default to CI_COMMIT_SHA.

The scanner should sign in the Docker registry using the variables DOCKER_USER and DOCKER_PASSWORD. If these are not defined, then the scanner should use CI_REGISTRY_USER and CI_REGISTRY_PASSWORD as default values.

Configuration files
While scanners may use CI_PROJECT_DIR to load specific configuration files, it is recommended to expose configuration as CI/CD variables, not files.

Output file
Like any artifact uploaded to GitLab CI/CD, the Secure report generated by the scanner must be written in the project directory, given by the CI_PROJECT_DIR CI/CD variable.

It is recommended to name the output file after the type of scanning, and to use gl- as a prefix. Since all Secure reports are JSON files, it is recommended to use .
json as a file extension. For instance, a suggested filename for a Dependency Scanning report is gl-dependency-scanning.json.

Orchestrator Exit Code	Description
3	No match, no compatible analyzer
4	Project directory empty
5	No compatible Docker image
Logging


The scanner should log error messages and warnings so that users can easily investigate misconfiguration and integration issues by looking at the log of the CI scanning job.

Scanners may use ANSI escape codes to colorize the messages they write to the Unix standard output and standard error streams.
We recommend using red to report errors, yellow for warnings, and green for notices. Also, we recommend prefixing error messages with [ERRO], warnings with [WARN], and notices with [INFO].

Logging level
The scanner should filter out a log message if its log level is lower than the one set in the SECURE_LOG_LEVEL CI/CD variable. For instance, 
info and warn messages should be skipped when SECURE_LOG_LEVEL is set to error. Accepted values are as follows, listed from highest to lowest:
fatal
error
warn
info
debug
It is recommended to use the debug level for verbose logging that could be useful when debugging. 
The default value for SECURE_LOG_LEVEL should be set to info.

When executing command lines, scanners should use the debug level to log the command line and its output. For instance,
the bundler-audit scanner uses the debug level to log the command line bundle audit check --quiet, and what bundle audit writes to the standard output. If the command line fails, then it should be logged with the error log level; this makes it possible to debug the problem without having to change the log level to debug and rerun the scanning job.

common logutil package

If you are using go and common, then it is suggested that you use Logrus and common’s logutil package to configure the formatter for Logrus. See the logutil README

Report
The report is a JSON document that combines vulnerabilities with possible remediations.

This documentation gives an overview of the report JSON format, as well as recommendations and examples to help integrators set its fields. 
The format is extensively described in the documentation of SAST, DAST, Dependency Scanning, and Container Scanning.

You can find the schemas for these scanners here:

SAST
DAST
Dependency Scanning
Container Scanning
Coverage Fuzzing
Secret Detection
Version

This field specifies the version of the Security Report Schemas you are using. Please refer to the releases of the schemas for the specific versions to use.

Vulnerabilities
The vulnerabilities field of the report is an array of vulnerability objects.

ID
The id field is the unique identifier of the vulnerability. It is used to reference a fixed vulnerability from a remediation objects. 
We recommend that you generate a UUID and use it as the id field’s value.

Category

The value of the category field matches the report type: dependency_scanning, container_scanning, sast, and dast.

Scanner
The scanner field is an object that embeds a human-readable name and a technical id. The id should not collide with any other scanner another integrator would provide.

Name, message, and description
The name and message fields contain a short description of the vulnerability. The description field provides more details.

The name field is context-free and contains no information on where the vulnerability has been found, whereas the message may repeat the location.

For instance, a message for a vulnerability reported by Dependency Scanning gives information on the vulnerable dependency, which is redundant with the location field of the vulnerability. The name field is preferred but the message field is used when the context/location cannot be removed from the title of the vulnerability.

To illustrate, here is an example vulnerability object reported by a Dependency Scanning scanner, and where the message repeats the location field:

As a visual example, this screenshot highlights where these fields are used when viewing a vulnerability as part of a pipeline view.

Example Vulnerability

{
    "location": {
        "dependency": {
            "package": {
            "name": "debug"
          }
        }
    },
    "name": "Regular Expression Denial of Service",
    "message": "Regular Expression Denial of Service in debug",
    "description": "The debug module is vulnerable to regular expression denial of service
        when untrusted user input is passed into the `o` formatter.
        It takes around 50k characters to block for 2 seconds making this a low severity issue."
}


The description might explain how the vulnerability works or give context about the exploit. It should not repeat the other fields of the vulnerability object. 
In particular, the description should not repeat the location (what is affected) or the solution (how to mitigate the risk).

Solution
You can use the solution field to instruct users how to fix the identified vulnerability or to mitigate the risk. 
End-users interact with this field, whereas GitLab automatically processes the remediations objects.

Identifiers


